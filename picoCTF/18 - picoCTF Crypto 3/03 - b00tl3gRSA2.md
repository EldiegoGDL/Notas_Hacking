## Descripción
In RSA d is a lot bigger than e, why don't we use d to encrypt instead of e? Connect with nc jupiter.challenges.picoctf.org 18243.
## Solución
```
c= 57281141219672725434435919655132405720746352196417024097520094361252471621138307296250044173987712648152591123867122656195255855206879167808443501409298469234340158190934372787279255796576598138284924115819514785631992745670157117319353785519603857839332961044024767525426886744563121995637371683855175307535
n= 69749023505375469514024427287866438366051174087803335641454874749299455455681585660051906696781227002699397516848825720242823480748561018504907687065018858924062686781653793628400814468052740848131645753075097237250395787808103153422676644850186060900293831025843985016994616031740569052302655957393616366523
e= 224560842877065231357235670807937783164270530120794418730594604148834781896467866613835731159815659819179591315670571234130884148464933928994850572512000483824893622840265461949614093570376755515064046219431365505945135306955938021280955472815377341263792275762294216915126409319644026964674525456427535897

e = 65537
m = pow(c,e,n)
print(m)


flag = bytes.fromhex(hex(m)[2:]).decode()

print(flag)
```

picoCTF{bad_1d3a5_4783252}
## Notas adicionales
+ con la coneccion nc nos proporcionaron un texto en codigo ASCii
+ con los valores de c ,n y e
+ y sabiendo su contenido hacemos un codigo en python para manipular los valores segun lo que se requiere para conseguir el texto encriptado calculando m
## Referencias
